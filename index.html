<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8">
    <title>SF3 Specification</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="alert">
      <header>This is a Draft Specification</header>
      This document is not finalised. Do not use its contents as a reference as they may change in the future as the specification process advances.
    </div>
    <main><article><h1 id="About SF3">About SF3</h1><p>SF3 (Simple File Format Family) is a family of file format specifications. These file formats all follow a similar scheme and the same principles.</p><h1 id="Principles">Principles</h1><p>SF3 formats follow these principles:</p><ul><li><p><strong>No versioning</strong><br>These formats explicitly do not include any versioning at all. The way they are described in this document is final and will not change. This means the formats are eternally forwards and backwards compatible.</p></li><li><p><strong>No extensibility</strong><br>There are no vendor extensibility blocks or other parts that could be added by third parties. This ensures that a consumer of these formats will always be able to read the full file and know what every single bit in it means.</p></li><li><p><strong>No optional blocks</strong><br>There are no optional blocks or parts in the formats that could be omitted. This means there is no conditional parsing needed and the structure of the files is always clear.</p></li><li><p><strong>Only raw data</strong><br>The data is not compressed, encrypted, or otherwise transformed. Data is always raw. If encryption or compression is desired, the entire file can instead be wrapped in a compression or encryption stream (gzip, lzma, etc).</p></li><li><p><strong>Always little-endian</strong><br>The formats are always little-endian wherever byte order matters. This is compatible with the vast majority of processors and software today and means no byte rearrangement is necessary when loading to memory.</p></li><li><p><strong>Similar layout</strong><br>Each format in the family follows a very similar format of identifier, header, and payload. This ensures that the files remain easy to parse, understand, and debug.</p></li></ul><h1 id="Specification Description">Specification Description</h1><p>The format specifications in this document use a BNF-style abstract syntax language. The language is defined here:</p><code style="display:block" class="code-block" data-language="BNF"><pre>Format       ::= Definition+
Definition   ::= Rule Identifier? Description? '\n'
Identifier   ::= '::=' Sequence
Description  ::= '---' text
Sequence     ::= Composition (' ' Composition)*
Composition  ::= (Rule | OctetArray | Octet | Type | '(' Sequence ')') (OneOrMore | AnyNumber | ExactNumber)?
OctetArray   ::= '[' (octet | ascii) (' ' (octet | ascii))* ']'
Type         ::= ('int' | 'uint') IntBittage | 'float' FloatBittage | 'string' ExactNumber
IntBittage   ::= '8' | '16' | '24' | '32' | '64'
FloatBittage ::= '16' | '32' | '64'
Rule         ::= name
OneOrMore    ::= '+'
AnyNumber    ::= '*'
ExactNumber  ::= '{' number '}'

name         --- The name of a rule as a sequence of non-numeric ASCII characters.
octet        --- Eight bits expressed as two hexadecimal digits.
ascii        --- Eight bits expressed as an ASCII character whose codepoint is the octet value.
text         --- Human-readable textual description of the contents.
number       --- A textual description of the number of occurrences. Can make a reference to other rules, in which case the rule's content designates a runtime number.</pre></code><p>White space unless otherwise mandated may be inserted liberally to aid readability. Each rule ultimately defines a sequence of octets that should be parsed. The <code>Type</code>s mentioned translate to signed integers, unsigned integers, and IEEE floating point numbers of the given number of bits. <code>string</code> designates a UTF-8 encoded character sequence with an octet length as indicated by the required following <code>ExactNumber</code> rule.</p><h1 id="Formats">Formats</h1><p>Each format is made up of the following structure, where a valid file must begin with the <code>File</code> rule.</p><code style="display:block" class="code-block" data-language="BNF"><pre>File       ::= Identifier Header Payload
Identifier ::= [ 81 S F 3 00 E0 D0 0D 0A 0A ] format-id
format-id  --- A single octet identifying the format.</pre></code><p>The rationale for the ten octets in the identifier is as follows:</p><ul><li><p><code>81</code> An octet to stop byte-peekers from determining text. The octet lies in the undefined ranges of ASCII, ISO-8859-1, Windows-1252, and SJIS.</p></li><li><p><code>SF3</code> ASCII identifier for human-readability.</p></li><li><p><code>00</code> A null octet to stop C-string utilities from trying to munch the rest of the file.</p></li><li><p><code>E0D0</code> An invalid UTF-8 octet sequence.</p></li><li><p><code>0D0A0A</code> A CRLFLF sequence to catch bad line conversion utilities.</p></li></ul><p>The <code>Header</code> and <code>Payload</code> will be described by the individual formats.<br>The values for the <code>format-id</code> are interpreted as follows:</p><ul><li><p><code>00</code> — Text</p></li><li><p><code>01</code> — Image</p></li><li><p><code>02</code> — Audio</p></li><li><p><code>03</code> — Model</p></li><li><p><code>04</code> — Archive</p></li></ul><p>Any other value for the <code>format-id</code> is invalid.</p><h2 id="Archive">Archive</h2><p>The Archive format allows storing multiple files in one binary package. The file also includes some metadata so that the files can be stored with a relative path and mime-type, allowing both file-system extraction, and content inspection without explicit extraction.</p><code style="display:block" class="code-block" data-language="BNF"><pre>Header       ::= Count MetadataSize
Payload      ::= Metadata Files
MetadataSize ::= uint32                --- The octet size of the Metadata payload.
Metadata     ::= EntryOffset{Count} MetaEntry{Count}
EntryOffset  ::= uint32                --- The octet offset of the corresponding MetaEntry from the beginning of Metadata.
MetaEntry    ::= FileSize Mime Path    --- A descriptor of file size, mime type, and path.
FileSize     ::= uint32                --- The size of the corresponding file in bytes.
Mime         ::= uint8 string{uint8}   --- The mime-type of the corresponding file.
Path         ::= uint16 string{uint16} --- The relative path of the corresponding file.
Files        ::= FileOffset{Count} File{Count}
FileOffset   ::= uint32                --- The octet offset of the corresponding File from the beginning of Files. 
File         ::= uint8{OctetSize}      --- A binary file payload.</pre></code><p>The included <code>MetadataSize</code>, <code>EntryOffset</code>, and <code>FileOffset</code> fields should allow constant-time access to any content within the archive.<br>If no mime-type is known for a file that should be stored, the corresponding <code>Mime</code> should be set to <code>application/octet-stream</code>.</p><h2 id="Audio">Audio</h2><p>This format is for storing plain audio sample data. It includes support for all types of sample formats and channel numbers out there. Unlike other formats, it also enforces the channel data to be interleaved rather than sequential, which foregoes the need for a length field, allowing the file to be written on the fly.</p><code style="display:block" class="code-block" data-language="BNF"><pre>Header     ::= Samplerate Channels format 
Payload    ::= sample{Channels}*
Samplerate ::= uint32 --- The samplerate in Hz.
Channels   ::= uint8  --- The number of audio channels.
format     --- A single octet identifying the per-sample data type.
sample     --- A single-channel sample value in the format indicated by format.</pre></code><p>The values for <code>format</code> are interpreted as follows:</p><ul><li><p><code>10</code> — <code>int8</code></p></li><li><p><code>20</code> — <code>int16</code></p></li><li><p><code>30</code> — <code>int24</code></p></li><li><p><code>40</code> — <code>int32</code></p></li><li><p><code>80</code> — <code>int64</code></p></li><li><p><code>11</code> — <code>uint8</code></p></li><li><p><code>21</code> — <code>uint16</code></p></li><li><p><code>31</code> — <code>uint24</code></p></li><li><p><code>41</code> — <code>uint32</code></p></li><li><p><code>81</code> — <code>uint64</code></p></li><li><p><code>42</code> — <code>float32</code></p></li><li><p><code>82</code> — <code>float64</code></p></li></ul><p>Any other value for <code>format</code> is invalid. <br>The length of the payload is unbounded, but must always be a multiple of <code>Channels*format-bits</code> number of bits.</p><h2 id="Image">Image</h2><p>This format is for storing raw image data. Unlike plain data however, it includes a header that completely identifies the pixel data layout and format. The format supports 3D images as well.</p><code style="display:block" class="code-block" data-language="BNF"><pre>Header        ::= Width Height Depth channels format
Payload       ::= Layer{Depth}
Layer         ::= Row{Height}
Row           ::= Color{Width}
Color         ::= channel{channel-count}
Width         ::= uint32
Height        ::= uint32
Depth         ::= uint32
format        --- A single octet identifying the per-channel data type.
channels      --- A single octet identifying the number and order of channels.
channel       --- A single-channel colour value in the format indicated by format.
channel-count --- The number of channels indicated by channels.</pre></code><p>The values for <code>format</code> are interpreted as follows:</p><ul><li><p><code>10</code> — <code>int8</code></p></li><li><p><code>20</code> — <code>int16</code></p></li><li><p><code>40</code> — <code>int32</code></p></li><li><p><code>80</code> — <code>int64</code></p></li><li><p><code>11</code> — <code>uint8</code></p></li><li><p><code>21</code> — <code>uint16</code></p></li><li><p><code>41</code> — <code>uint32</code></p></li><li><p><code>81</code> — <code>uint64</code></p></li><li><p><code>22</code> — <code>float16</code></p></li><li><p><code>42</code> — <code>float32</code></p></li><li><p><code>82</code> — <code>float64</code></p></li></ul><p>Any other value for <code>format</code> is invalid. <br>The values for <code>channels</code> are interpreted as follows:</p><ul><li><p><code>10</code> — <code>R</code></p></li><li><p><code>20</code> — <code>RG</code></p></li><li><p><code>30</code> — <code>RGB</code></p></li><li><p><code>40</code> — <code>RGBA</code></p></li><li><p><code>21</code> — <code>GR</code></p></li><li><p><code>31</code> — <code>BGR</code></p></li><li><p><code>41</code> — <code>ABGR</code></p></li><li><p><code>42</code> — <code>ARGB</code></p></li><li><p><code>43</code> — <code>BGRA</code></p></li></ul><p>Any other value for <code>channels</code> is invalid.<br>The payload must have exactly <code>Width*Height*Depth*channel-count*format-bits</code> number of bits.</p><h2 id="Model">Model</h2><p>This format is for singular triangular meshes only. It does not include a scene graph or the capability for non-triangular or non-static meshes. If animation of the model is desired, animation information can be delivered separately.</p><code style="display:block" class="code-block" data-language="BNF"><pre>Header         ::= format material-type MaterialSize Count
Payload        ::= Material Faces Vertices
MaterialSize   ::= uint32                  --- The octet size of the Material payload.
Count          ::= uint32                  --- The number of entries in the Faces array.
Material       ::= Texture{material-count} --- An array of texture maps for the model's material.
Texture        ::= uint16 string{uint16}   --- A relative file path to an image.
Faces          ::= uint32{Count}           --- An array of 0-based indices into the Vertices array.
Vertices       ::= vertex*
Position       ::= float32 float32 float32 --- A vertex position in model-space.
UV             ::= float32 float32         --- A texture coordinate in texture-space.
Color          ::= float32 float32 float32 --- An RGB colour triplet, each channel in [0,1].
Normal         ::= float32 float32 float32 --- A surface normal, in tangent-space.
Tangent        ::= float32 float32 float32 --- A surface tangent, in tangent-space.
format         --- A single octet identifying the per-vertex format.
material-type  --- A single octet identifying the material used.
material-count --- The number of material textures as indicated by material-type.
vertex         --- A single-vertex value in the format indicated by format.</pre></code><p>The values for <code>format</code> are interpreted as follows, and describe the layout of the <code>vertex</code>:</p><ul><li><p><code>10</code> — <code>Position</code></p></li><li><p><code>20</code> — <code>Position</code> <code>UV</code></p></li><li><p><code>21</code> — <code>Position</code> <code>Color</code></p></li><li><p><code>22</code> — <code>Position</code> <code>Normal</code></p></li><li><p><code>30</code> — <code>Position</code> <code>UV</code> <code>Normal</code></p></li><li><p><code>31</code> — <code>Position</code> <code>Color</code> <code>Normal</code></p></li><li><p><code>40</code> — <code>Position</code> <code>UV</code> <code>Normal</code> <code>Tangent</code></p></li></ul><p>Any other value for <code>format</code> is invalid. <br>The values for <code>material-type</code> are interpreted as follows, and describe the usage and number of <code>Texture</code>s:</p><ul><li><p><code>00</code> —</p></li><li><p><code>10</code> — Albedo</p></li><li><p><code>20</code> — Albedo Normal</p></li><li><p><code>21</code> — Albedo Emission</p></li><li><p><code>30</code> — Albedo Normal Specular</p></li><li><p><code>31</code> — Albedo Normal Emission</p></li><li><p><code>32</code> — Albedo Normal Metallic</p></li><li><p><code>40</code> — Albedo Normal Metalness Roughness</p></li><li><p><code>41</code> — Albedo Normal Specular Emission</p></li><li><p><code>42</code> — Albedo Normal Metallic Emission</p></li><li><p><code>50</code> — Albedo Normal Metalness Roughness Emission</p></li><li><p><code>51</code> — Albedo Normal Metalness Roughness Occlusion</p></li><li><p><code>60</code> — Albedo Normal Metalness Roughness Occlusion Emission</p></li></ul><p>Any other value for <code>material-type</code> is invalid.<br>The Metallic texture is a combination of Metalness, Roughness, and Occlusion in the R, G, and B channels respectively.</p><p>The included <code>MaterialSize</code> field should allow constant-time access to the vertex data without having to parse the <code>Material</code> structure, if that structure is not needed. The number of <code>vertex</code> entries in the <code>Vertices</code> should be as high as the highest index in the <code>Faces</code> array, and cannot exceed <code>Count</code>. Similarly, each entry in the <code>Faces</code> array must be lower than <code>Count</code>.</p><h2 id="Text">Text</h2><p>The text format identifies the character encoding used, followed by the raw text payload. Essentially this means it is a regular &quot;text file&quot;, but with a header that identifies the actual encoding used and thus liberates the need for encoding detecting kludges.</p><code style="display:block" class="code-block" data-language="BNF"><pre>Header   ::= encoding
Payload  ::= text
encoding --- A single octet identifying a text encoding.
text     --- A sequence of octets in the encoding described by the header.</pre></code><p>The values for <code>encoding</code> are interpreted as follows:</p><ul><li><p><code>00</code> — US-ASCII</p></li><li><p><code>10</code> — UTF-8</p></li><li><p><code>11</code> — UTF-16</p></li><li><p><code>12</code> — UTF-32</p></li><li><p><code>20</code> — ISO 8859-1</p></li><li><p><code>21</code> — ISO 8859-2</p></li><li><p><code>22</code> — ISO 8859-3</p></li><li><p><code>23</code> — ISO 8859-4</p></li><li><p><code>24</code> — ISO 8859-5</p></li><li><p><code>25</code> — ISO 8859-6</p></li><li><p><code>26</code> — ISO 8859-7</p></li><li><p><code>27</code> — ISO 8859-8</p></li><li><p><code>28</code> — ISO 8859-9</p></li><li><p><code>29</code> — ISO 8859-10</p></li><li><p><code>2A</code> — ISO 8859-11</p></li><li><p><code>2B</code> — ISO 8859-12</p></li><li><p><code>2C</code> — ISO 8859-13</p></li><li><p><code>2D</code> — ISO 8859-14</p></li><li><p><code>2E</code> — ISO 8859-15</p></li><li><p><code>2F</code> — ISO 8859-16</p></li><li><p><code>30</code> — Windows-874</p></li><li><p><code>31</code> — Windows-1250</p></li><li><p><code>32</code> — Windows-1251</p></li><li><p><code>33</code> — Windows-1252</p></li><li><p><code>34</code> — Windows-1253</p></li><li><p><code>35</code> — Windows-1254</p></li><li><p><code>36</code> — Windows-1255</p></li><li><p><code>37</code> — Windows-1256</p></li><li><p><code>40</code> — EUC-CN</p></li><li><p><code>41</code> — EUC-JP</p></li><li><p><code>42</code> — EUC-KR</p></li><li><p><code>43</code> — EUC-TW</p></li><li><p><code>50</code> — Shift JIS</p></li><li><p><code>51</code> — Big5</p></li><li><p><code>52</code> — GBK</p></li></ul><p>Any other value for the <code>encoding</code> is invalid.</p><h1 id="Metadata">Metadata</h1><p>These formats can be delivered as part of a binary stream or deposited in a file system. The following are recommendation for metadata identifiers to distinguish SF3 data without having to parse it.</p><h2 id="Mime-Type">Mime-Type</h2><p>The mime-types for SF3 files should be as follows, according to the format used:</p><ul><li><p><strong>Archive</strong> <code>application/x.sf3-archive</code></p></li><li><p><strong>Audio</strong> <code>audio/x.sf3</code></p></li><li><p><strong>Image</strong> <code>image/x.sf3</code></p></li><li><p><strong>Model</strong> <code>model/x.sf3</code></p></li><li><p><strong>Text</strong> <code>text/x.sf3</code></p></li></ul><p>If a general SF3 file should be designated, the mime-type should be <code>application/x.sf3</code>. If/when the IANA registration for an official mime-type is approved, the <code>x.</code> prefix may be dropped.</p><h2 id="File Extension">File Extension</h2><p>The file extension should always end with <code>.sf3</code>. Specifically, for the formats the following extended extensions may be used:</p><ul><li><p><strong>Archive</strong> <code>.ar.sf3</code></p></li><li><p><strong>Audio</strong> <code>.au.sf3</code></p></li><li><p><strong>Image</strong> <code>.img.sf3</code></p></li><li><p><strong>Model</strong> <code>.mod.sf3</code></p></li><li><p><strong>Text</strong> <code>.txt.sf3</code></p></li></ul></article></main>
  </body>
</html>
